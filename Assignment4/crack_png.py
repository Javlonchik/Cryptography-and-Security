#Write a python code that crack the used random number generator, based on the following scenario:
#Assume you got a ciphertext (in hexa) that  is  b'62716b6b777862677362667e7b',  as a result of XOR encryption (ASCII encoding is used).
#Additionally, assume that you know the original encrypted plaintext was 'cybersecurity'
#You know that the key were random numbers generated by LCG. This means that e ach character in the plaintext has been encrypted (XORed) with a single generated random number of LCG
#By knowing the above information, crack the LCG parameters.

#code here:
import random
import binascii
import string
import sys

def lcg(seed, a, c, m):
    while True:
        seed = (a * seed + c) % m
        yield seed

def crack_lcg(ciphertext, plaintext):
    # ciphertext is a hex string
    # plaintext is a string
    ciphertext = binascii.unhexlify(ciphertext)
    assert len(ciphertext) == len(plaintext)
    # convert plaintext to a list of integers
    plaintext = [ord(c) for c in plaintext]
    # convert ciphertext to a list of integers
    ciphertext = [c for c in ciphertext]
    # get the first 3 numbers from the LCG
    lcg_numbers = [c ^ p for c, p in zip(ciphertext, plaintext)]
    # get the seed from the first number
    seed = lcg_numbers[0]
    # get the next two numbers
    a = lcg_numbers[1]
    c = lcg_numbers[2]
    # get the modulus
    m = 256
    # return the LCG parameters
    return seed, a, c, m

def main():
    # ciphertext is a hex string
    ciphertext = '62716b6b777862677362667e7b'
    # plaintext is a string
    plaintext = 'cybersecurity'
    # crack the LCG
    seed, a, c, m = crack_lcg(ciphertext, plaintext)
    # print the LCG parameters
    print('seed =', seed)
    print('a =', a)
    print('c =', c)
    print('m =', m)


if __name__ == '__main__':
    main()


'''
This Python code is an implementation of a Linear Congruential Generator (LCG) and a program to crack the LCG given a ciphertext and corresponding plaintext.

The lcg() function in the code is an implementation of the LCG formula. It takes as input the seed, a, c, and m, and uses a while loop to generate an infinite sequence of numbers. Each time the loop runs, it calculates the next number in the sequence using the LCG formula, and yields that number. This means that the lcg() function can be used to generate as many pseudorandom numbers as needed.

The crack_lcg() function takes a ciphertext and corresponding plaintext as input, and uses them to determine the values of the LCG parameters (seed, a, c, and m) that were used to generate the ciphertext. To do this, it first converts the ciphertext and plaintext from their hex string and string formats, respectively, to lists of integers. It then uses these lists to calculate the first three numbers in the LCG sequence, which are the XOR of the first three ciphertext and plaintext pairs. These numbers are used to determine the seed, a, and c values, while the modulus is hardcoded as 256.

The main() function in the code simply sets the ciphertext and plaintext, calls the crack_lcg() function to determine the LCG parameters, and then prints out the values of the parameters.

Overall, this code demonstrates how an LCG can be used to generate pseudorandom numbers, and how it can be cracked given knowledge of the plaintext and corresponding ciphertext. However, it's important to note that LCGs are not considered to be cryptographically secure, as the generated numbers can be predicted if the LCG parameters are known.
'''
